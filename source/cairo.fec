uses 'cairo.lib';
uses 'pango';

module-header
{
	#include <cairo/cairo.h>
	#include <cairo/cairo-pdf.h>
	#include <pango-1.0/pango/pangocairo.h>
}

/**
 * @namespace Cairo
 * @brief Provides a set of classes to create vector graphics.
 */
namespace Cairo
{
	final number FONT_SLANT_NORMAL = 0;
	final number FONT_SLANT_ITALIC = 1;
	final number FONT_SLANT_OBLIQUE = 2;
	
	final number FONT_WEIGHT_NORMAL = 0;
	final number FONT_WEIGHT_BOLD = 1;
	
	/**
	 * @class Context
	 * @brief The Cairo drawing context.
	 */
	class Context
	{
		native function constructor()
		{
			FE_RETURN_NULL_OBJECT;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( object surface )
		 * @brief This is the constructor for the class Context.
		 * @param object surface a Cairo surface
		 * @return A newly created Cairo context object.
		 */
		native function constructor( object surface )
		{
			/* NOTICE: ferite_object_is_sub_?_lass  */
			if( ferite_object_is_sublass( surface, "Surface" ) == FE_TRUE )
			{
				cairo_surface_t* cairo_surface = surface->odata;
				cairo_t* context = cairo_create( cairo_surface );
				self->odata = context;
			}
		}
		
		native function destructor( )
		{			
			if( self->odata )
			{
				cairo_t* context = self->odata;
				cairo_destroy( context );
			}
		}
		
		/**
		 * @function showPage
		 * @declaration function showPage( )
		 * @breif Emits and clears the current page for backends that support
		          multiple pages.
		 * @description Emits and clears the current page for backends that
		                support multiple pages. Use copyPage() if you don't want
		                to clear the page.
		 */
		native function showPage( )
		{
			cairo_t* context = self->odata;
			cairo_show_page( context );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function paint
		 * @declaration function paint( )
		 * @brief Paints the current source everywhere within the current clip region
		 */
		native function paint( )
		{
			cairo_t* context = self->odata;
			cairo_paint( context );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function fill
		 * @declaration function fill( )
		 * @brief Fills the current path
		 */
		native function fill( )
		{
			cairo_t* context = self->odata;
			cairo_fill( context );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function setSourceRGB
		 * @declaration function setSourceRGB( number red, number green, number blue )
		 * @biref Sets the source pattern within context to an opaque color.
		 * @param number red red component of color
		 * @param number green component of color
		 * @param number blue blue component of color
		 * @description This opaque color will then be used for any subsequent
		                drawing operation until a new source pattern is set.
		                The color components are floating point numbers in the
		                range 0 to 1. If the values passed in are outside that
		                range, they will be clamped.
		 */
		native function setSourceRGB(number red, number green, number blue)
		{
			cairo_t* context = self->odata;
			cairo_set_source_rgb( context, red, green, blue );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function selectFontFace
		 * @declaration function selectFontFace( string family, number slant, number weight )
		 * @brief Selects a family and style of font from a simplified
		          description as a family name, slant and weight.
		 * @param string family a font family name
		 * @param number slant the slant for the font
		 * @param number weight the weight for the font
		 * @description This function is meant to be used only for applications
		                with simple font needs: Cairo doesn't provide for
		                operations such as listing all available fonts on the
		                system, and it is expected that most applications will
		                need to use a more comprehensive font handling and text
		                layout library in addition to cairo.
		 */
		native function selectFontFace( string family, number slant, number weight )
		{
			cairo_font_slant_t cairo_slant;
			cairo_font_weight_t cairo_weight;
			
			/* WARNING: Very ugly. Please resolv this somehow. */
			if( slant == 0.0 )
			{
				cairo_slant = CAIRO_FONT_SLANT_NORMAL;
			}
			else if( slant == 1.0 )
			{
				cairo_slant = CAIRO_FONT_SLANT_ITALIC;
			}
		 	else if( slant == 2.0 )
		 	{
		 		cairo_slant = CAIRO_FONT_SLANT_OBLIQUE;
		 	}
		 	
		 	if( weight == 0.0 )
		 	{
		 		cairo_weight = CAIRO_FONT_WEIGHT_NORMAL;
		 	}
			else if( weight == 1.0 )
		 	{
				cairo_weight = CAIRO_FONT_WEIGHT_BOLD;
			}
			
			cairo_t* context = self->odata;
			
			cairo_select_font_face( context, family->data, cairo_slant, cairo_weight );
			
			FE_RETURN_VOID;
		}
		
		/**
		 * @function setFontSize
		 * @declaration function setFontSize( number size )
		 * @brief Sets the size of the font.
		 * @param number size The size of the font.
		 */
		native function setFontSize( number size )
		{
			cairo_t* context = self->odata;
			cairo_set_font_size( context, size );
		 	FE_RETURN_VOID;
		}
		
		/**
		 * @function moveTo
		 * @declaration function moveTo( number x, number y )
		 * @brief Move to a position within the document.
		 * @param number x The X coordinate of the new position.
		 * @param number y The Y coordinate of the new position.
		 */
		native function moveTo(number x, number y)
		{
			cairo_t* context = self->odata;
			cairo_move_to( context, x, y );
			FE_RETURN_VOID;
		}
		 
		/**
		 * @function showText
		 * @declaration function showText( string text )
		 * @brief Draws a string of text.
		 * @param string text A string of text.
		 */
		native function showText(string text)
		{
			cairo_t* context = self->odata;
			cairo_show_text(context, text->data );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function setSourceSurface
		 * @declaration function setSourceSurface( object surface, number x, number y )
		 * @brief Create a pattern from a surface and set it as the source
		 * @param object surface A surface to be used to set the source pattern
		 * @param number x User-space X coordinate for surface origin
		 * @param number y User-space Y coordinate for surface origin
		 */
		native function setSourceSurface( object surface, number x, number y )
		{
			/* NOTICE: ferite_object_is_sub_?_lass  */
			if( ferite_object_is_sublass( surface, "Surface" ) == FE_TRUE )
			{
				cairo_t* context = self->odata;
				cairo_surface_t* cairo_surface = surface->odata;
				cairo_set_source_surface( context, cairo_surface, x, y );
			}
			FE_RETURN_VOID;
		}
		
		/**
		 * @function createPangoLayout
		 * @declaration function createPangoLayout( )
		 * @brief Creates a Pango layout object.
		 * @return A Pango layout object.
		 * @description Creates a layout object set up to match the current
		                transformation and target surface of the Cairo context.
		 */
		native function createPangoLayout( )
		{
			FeriteNamespaceBucket* nsb = NULL;
			
			FeriteClass* layout_class = NULL;
			FeriteVariable* layout_object = NULL;
			
			PangoLayout* pango_layout = NULL;
			
			cairo_t* context = self->odata;
						
			nsb = ferite_find_namespace(script, script->mainns, "Pango.Layout", FENS_CLS);
			
			if( NULL != nsb )
			{
				layout_class = nsb->data;
				layout_object = ferite_build_object( script, layout_class );
				UNMARK_VARIABLE_AS_DISPOSABLE( layout_object );
				
				pango_layout = pango_cairo_create_layout( context );
								
				VAO(layout_object)->odata = pango_layout;
				
				FE_RETURN_OBJECT( VAO( layout_object ) );
			}
			
			FE_RETURN_NULL_OBJECT;
		}
		
		/**
		 * @function showPangoLayoutLine
		 * @declaration function showPangoLayoutLine( object layoutLine )
		 * @brief Draws a Pango.LayoutLine in the specified cairo context.
		 * @params object A PangoLayoutLine.
		 * @description The origin of the glyphs (the left edge of the line)
		                will be drawn at the current point of the cairo context.
		 */
		native function showPangoLayoutLine( object layoutLine )
		{
			FeriteNamespaceBucket* nsb = NULL;
			nsb = ferite_find_namespace( script, script->mainns, "Pango.LayoutLine", FENS_CLS );
			
			if( nsb != NULL )
			{
				FeriteClass* klass = nsb->data;
				
				if( ferite_class_is_subclass( klass,  layoutLine->klass ) == FE_TRUE )
				{
					cairo_t* context = self->odata;
					PangoLayoutLine* layout_line = layoutLine->odata;
					pango_cairo_show_layout_line(context, layout_line );
				}
			}
			
			FE_RETURN_VOID;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class Surface
	 * @brief Base class for cairo surfaces.
	 */
	abstract class Surface
	{
		native function writeToPNG( string filename )
		{
			cairo_surface_t* surface = self->odata;
			cairo_surface_write_to_png( surface, filename->data );
			FE_RETURN_VOID;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class ImageSurface
	 * @extends Cairo.Surface
	 */
	class ImageSurface extends Surface
	{
		native function constructor( )
		{
			FE_RETURN_NULL_OBJECT;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( number width, number height )
		 * @param number width The width
		 * @param number height The height
		 */
		native function constructor( number width, number height )
		{
			/*
			 * NOTE: This is ugly. Please do something about it.
			 * Q: Should these be type casted to ints instead?
			 */
			long long_width = 0;
			long long_height = 0;
			
			if( width < LONG_MAX )
			{
				long_width = (long)width;
			}
			
			if( height < LONG_MAX )
			{
				long_height = (long)height;
			}
			
			/*
			 * ALSO NOTE: I have no idea what happens here if long_width or
			 * long_height is bigger then an int.
			 *
			 * NOTE AGAIN: CAIRO_FORMAT_RGB24 should not be hard coded here.
			 * We want it as an argument to the function.
			 */
			cairo_surface_t* surface = cairo_image_surface_create( CAIRO_FORMAT_RGB24, long_width, long_height );
			super->odata = surface;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string filename )
		 * @brief Creates a new ImageSurface from a PNG file
		 * @param string filename Name of PNG file to load
		 * @return A new ImageSurface
		 */
		native function constructor( string filename )
		{
			cairo_surface_t* surface = cairo_image_surface_create_from_png( filename->data );
			super->odata = surface;
		}
		
		native function destructor( )
		{
			if( super->odata )
			{
				cairo_surface_t* surface = super->odata;
				cairo_surface_destroy( surface );
			}
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PDFSurface
	 * @extends Cairo.Surface
	 * @brief A Cairo surface for drawing in PDF documents.
	 */
	class PDFSurface extends Surface
	{
		/**
		 * @function constructor
		 * @declaration function constructor( )
		 */
		native function constructor( )
		{
			cairo_surface_t* surface = cairo_pdf_surface_create( "pdffile.pdf", 595.28, 841.89 );
			super->odata = surface;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string filename, number width, number height )
		 */
		native function constructor( string filename, number width, number height )
		{
			cairo_surface_t* surface = cairo_pdf_surface_create( filename->data, width, height );
			super->odata = surface;
		}
		
		native function destructor( )
		{
			if( super->odata )
			{
				cairo_surface_t* surface = super->odata;
				cairo_surface_destroy( surface );
			}
		}
	}
	/**
	 * @end
	 */

}
/**
 * @end
 */

