uses 'cairo.lib';

module-header
{
	#include <cairo/cairo.h>
	#include <cairo/cairo-pdf.h>
	#include <pango-1.0/pango/pangocairo.h>
	
	typedef struct cairo_surface_data
	{
		cairo_surface_t* surface;
	
	} CairoSurfaceData;
	
	typedef struct cairo_context_data
	{
		cairo_t* context;
		
	} CairoContextData;
	
	typedef struct pango_font_description_data
	{
		PangoFontDescription* font_description;
		
	} PangoFontDescriptionData;
	
	typedef struct pango_layout_data
	{
		PangoLayout* layout;
		
	} PangoLayoutData;
	
	typedef struct pango_layout_line_data
	{
		PangoLayoutLine* layout_line;
		
	} PangoLayoutLineData;
}

/**
 * @namespace Cairo
 * @brief Provides a set of classes to create vector graphics.
 */
namespace Cairo
{
	final number FONT_SLANT_NORMAL = 0;
	final number FONT_SLANT_ITALIC = 1;
	final number FONT_SLANT_OBLIQUE = 2;
	
	final number FONT_WEIGHT_NORMAL = 0;
	final number FONT_WEIGHT_BOLD = 1;
	
	/**
	 * @class Context
	 * @brief The Cairo drawing context.
	 */
	class Context
	{
		native function constructor()
		{
			FE_RETURN_NULL_OBJECT;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( object surface )
		 * @brief This is the constructor for the class Context.
		 * @param object surface a Cairo surface
		 * @return A newly created Cairo context object.
		 */
		native function constructor( object surface )
		{
			CairoContextData* context_data = fmalloc( sizeof( CairoContextData ) );
			context_data->context = NULL;
			
			if( ferite_object_is_sublass( surface, "Surface" ) == FE_TRUE )
			{
				CairoSurfaceData* surface_data = surface->odata;
				context_data->context = cairo_create( surface_data->surface );
				self->odata = context_data;
			}
		}
		
		native function destructor( )
		{
			CairoContextData *context = self->odata;
			
			if( context->context )
			{
				cairo_destroy( context->context );
			}
			
			ffree( context );
		}
		
		/**
		 * @function showPage
		 * @declaration function showPage( )
		 * @breif Emits and clears the current page for backends that support
		          multiple pages.
		 * @description Emits and clears the current page for backends that
		                support multiple pages. Use copyPage() if you don't want
		                to clear the page.
		 */
		native function showPage()
		{
			CairoContextData* context = self->odata;
			cairo_show_page( context->context );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function setSourceRGB
		 * @declaration function setSourceRGB( number red, number green, number blue )
		 * @biref Sets the source pattern within context to an opaque color.
		 * @param number red red component of color
		 * @param number green component of color
		 * @param number blue blue component of color
		 * @description This opaque color will then be used for any subsequent
		                drawing operation until a new source pattern is set.
		                The color components are floating point numbers in the
		                range 0 to 1. If the values passed in are outside that
		                range, they will be clamped.
		 */
		native function setSourceRGB(number red, number green, number blue)
		{
			CairoContextData* context = self->odata;
			cairo_set_source_rgb( context->context, red, green, blue );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function selectFontFace
		 * @declaration function selectFontFace( string family, number slant, number weight )
		 * @brief Selects a family and style of font from a simplified
		          description as a family name, slant and weight.
		 * @param string family a font family name
		 * @param number slant the slant for the font
		 * @param number weight the weight for the font
		 * @description This function is meant to be used only for applications
		                with simple font needs: Cairo doesn't provide for
		                operations such as listing all available fonts on the
		                system, and it is expected that most applications will
		                need to use a more comprehensive font handling and text
		                layout library in addition to cairo.
		 */
		native function selectFontFace( string family, number slant, number weight )
		{
			cairo_font_slant_t cairo_slant;
			cairo_font_weight_t cairo_weight;
			
			if( slant == 0.0 )
			{
				cairo_slant = CAIRO_FONT_SLANT_NORMAL;
			}
			else if( slant == 1.0 )
			{
				cairo_slant = CAIRO_FONT_SLANT_ITALIC;
			}
		 	else if( slant == 2.0 )
		 	{
		 		cairo_slant = CAIRO_FONT_SLANT_OBLIQUE;
		 	}
		 	
		 	if( weight == 0.0 )
		 	{
		 		cairo_weight = CAIRO_FONT_WEIGHT_NORMAL;
		 	}
			else if( weight == 1.0 )
		 	{
				cairo_weight = CAIRO_FONT_WEIGHT_BOLD;
			}
			
			CairoContextData* context = self->odata;
			
			cairo_select_font_face( context->context, family->data, cairo_slant, cairo_weight );
			
			FE_RETURN_VOID;
		}
		 
		/**
		 * @function setFontSize
		 * @declaration function setFontSize( number size )
		 * @brief Sets the size of the font.
		 * @param number size The size of the font.
		 */
		native function setFontSize( number size )
		{
			CairoContextData* context = self->odata;
			cairo_set_font_size( context->context, size );
		 	FE_RETURN_VOID;
		}
		
		/**
		 * @function moveTo
		 * @declaration function moveTo( number x, number y )
		 * @brief Move to a position within the document.
		 * @param number x The X coordinate of the new position.
		 * @param number y The Y coordinate of the new position.
		 */
		native function moveTo(number x, number y)
		{
			CairoContextData* context = self->odata;
			cairo_move_to( context->context, x, y );
			FE_RETURN_VOID;
		}
		 
		/**
		 * @function showText
		 * @declaration function showText( string text )
		 * @brief Draws a string of text.
		 * @param string text A string of text.
		 */
		native function showText(string text)
		{
			CairoContextData* context = self->odata;
			cairo_show_text(context->context, text->data );
			FE_RETURN_VOID;
		}
		
		/**
		 * @function createPangoLayout
		 * @declaration function createPangoLayout( )
		 * @brief Creates a Pango layout object.
		 * @return object A Pango layout object.
		 * @description Creates a layout object set up to match the current
		                transformation and target surface of the Cairo context.
		 */
		native function createPangoLayout( )
		{
			FeriteNamespaceBucket* nsb = NULL;
			
			FeriteClass* layout_class = NULL;
			FeriteVariable* layout_object = NULL;
			
			PangoLayout* pango_layout = NULL;
			
			CairoContextData* context_data = self->odata;
						
			nsb = ferite_find_namespace(script, script->mainns, "Pango.Layout", FENS_CLS);
			
			if( NULL != nsb )
			{
				layout_class = nsb->data;
				
				layout_object = ferite_build_object( script, layout_class );
				
				UNMARK_VARIABLE_AS_DISPOSABLE( layout_object );
				
				pango_layout = pango_cairo_create_layout( context_data->context );
				
				PangoLayoutData* layout_data = fmalloc( sizeof( PangoLayoutData ) );
				layout_data->layout = NULL;
				layout_data->layout = pango_layout;
				
				VAO(layout_object)->odata = layout_data;
				
				FE_RETURN_OBJECT( VAO( layout_object ) );
			}
			
			FE_RETURN_NULL_OBJECT;
		}
		
		/**
		 * @function showPangoLayoutLine
		 * @declaration function showPangoLayoutLine( object layoutLine )
		 * @brief Draws a Pango.LayoutLine in the specified cairo context.
		 * @params object A PangoLayoutLine.
		 * @description The origin of the glyphs (the left edge of the line)
		                will be drawn at the current point of the cairo context.
		 */
		native function showPangoLayoutLine( object layoutLine )
		{
			if( ferite_object_is_sublass( layoutLine, "Pango.LayoutLine" ) == FE_TRUE )
			{
				CairoContextData* context_data = self->odata;
				PangoLayoutLineData* layout_line_data = layoutLine->odata;
				pango_cairo_show_layout_line(context_data->context, layout_line_data->layout_line );
			}
			
			FE_RETURN_VOID;
		}
	}
	/**
	 * @end
	 */
	
	/**
	 * @class Surface
	 * @brief Base class for cairo surfaces.
	 */
	abstract class Surface
	{
	}
	/**
	 * @end
	 */
	
	/**
	 * @class PDFSurface
	 * @extends Cairo.Surface
	 * @brief A Cairo surface for drawing in PDF documents.
	 */
	class PDFSurface extends Surface
	{
		/**
		 * @function constructor
		 * @declaration function constructor( )
		 */
		native function constructor( )
		{
			CairoSurfaceData* surface_data = fmalloc( sizeof( CairoSurfaceData ) );
			surface_data->surface = NULL;
			surface_data->surface = cairo_pdf_surface_create( "pdffile.pdf", 595.28, 841.89 );
			self->odata = surface_data;
		}
		
		/**
		 * @function constructor
		 * @declaration function constructor( string filename, number width, number height )
		 */
		native function constructor( string filename, number width, number height )
		{
			CairoSurfaceData* surface_data = fmalloc( sizeof( CairoSurfaceData ) );
			surface_data->surface = NULL;
			surface_data->surface = cairo_pdf_surface_create( filename->data, width, height );
			self->odata = surface_data;
		}
		
		native function destructor( )
		{
			CairoSurfaceData* surface_data = self->odata;
			
			if( surface_data->surface )
			{
				cairo_surface_destroy( surface_data->surface );
			}
			
			ffree( surface_data );
		}
	}
	/**
	 * @end
	 */

}
/**
 * @end
 */

